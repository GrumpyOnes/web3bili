https://learnblockchain.cn/2018/10/15/4d7f29608e40

1. Wei Gwei和Ether的区别：1Ether = 10^9Gwei = 10^18Wei

2. 以太网的平均区块间隔时间：约14s 。可以在Etherscan https://etherscan.io/chart/blocktime中查到每日的平均区块时间间隔。
3. 以太坊平均区块大小：约2Kb

> 不同于比特币使用区块大小来规定区块的交易量上限，以太坊使用燃料（gas）限制。燃料限制决定了每个区块中处理的交易量、存储/带宽的上限，因为交易和智能合约中函数的执行都要根据指令的复杂度多少来付出相应的燃料，所以使用燃料限制来约束区块大小是可行的。
>
> 燃料限制会随网络的波动和矿工的意愿变化，每个矿工都可以选择自己愿意接受的燃料价格。燃料价格就像是比特币中的交易费，只是这里的价格是最小单位燃料的价格，而不是每笔交易的价格。
>
> 想要算出一个区块中可以容纳多少笔交易，你不需要清楚地知道燃料的价格，只需知道平均每笔交易使用多少燃料并用整个燃料限制除以它即可。
>
> 去年以太猫的发行造成了以太坊网络的大拥堵，整个网络中充斥着大量未被处理的交易。在这种情况下矿工有两种选择。他们可以投票提高燃料限制来处理更多交易，也可以开始提高自己的燃料价格标准并拒绝处理燃料费用过低的交易。
>
> 与比特币一样，即使燃料价格很低的交易也可能会被处理加入区块链中，但矿工肯定会先处理完燃料价格高的交易再处理它。如果你的交易并没有那么紧急，设置一个很低的燃料价格也不是不可以，就像我们现实生活中的“花时间来节省金钱”。
>
> 如果有恶意用户持续地发起海量交易堵塞网络，全网的交易成本就会越来越高，直到这个恶意用户用完资金或者矿工赚足了交易费并决定扩大网络容量。

4. 以太坊是如何产生的：

> 1.2014年众筹并预售6000w以太币。2.矿工挖矿产生。

5. 节点是什么：一台连接到区块链，可以处理交易的计算机。
6. 以太坊网络：以太坊主网，以太坊测试网络，以太坊私有链。
7. 与以太坊交互的方法：电子钱包或Dapp
8. 是否能在以太坊中隐藏交易：不能，
9. 以太坊交易记录存在哪里：公共账本中，
10. 私有链的意义：数据涉及隐私，数据库去中心化，权限控制和测试。
11. 查看一笔交易或区块详细信息：区块链浏览器 etherscan.io或live.ether.camp
12. 查看私有链中的一笔交易或区块详细信息：一些开源的区块链浏览器满足这种需求，如etherparty推出的区块链浏览器
13. 区块链的共识过程：按照特定的协议验证交易，将交易打包进区块并加入区块链的过程。
14. 以太坊挖矿的工作原理：

> “套路”
>
> 简单地说，就是对于每个包含交易的区块，矿工使用计算机反复且非常快速地试验谜题的答案，直到有一个矿工猜对谜题。
>
> 更具体地说，矿工将当前区块唯一的区块头元数据（包括时间戳和软件版本）和一个随机数（nonce value）作为哈希函数的输入，函数将返回一个固定长度、看起来像是由数字和字母随机组成的乱码，叫做哈希值。哈希函数的特性是不同输入对应不同的哈希值，因此矿工仅需改变随机数的值，就会得到一个完全不同的哈希值。
>
> 如果算出来的哈希值小于当前的目标值（挖矿难度），则这个矿工就挖出了一个区块，他会获得一些以太币奖励，然后通过向全网络广播该区块，其他节点可以验证该区块中的交易，验证通过后将该区块加入到本地区块链的副本中。也就是说，如果矿工B算出了一个哈希值，矿工A将立刻停止当前区块的哈希值计算，把B挖出的区块加入区块链中并开始新一轮的哈希值计算。
>
> 矿工们很难在这场算力竞争中作弊。为了得到迷题的答案，除了一个个试没有更好的办法，也没有伪造这些计算工作的可能，这就是该解谜方法被称为“工作量证明”的原因。
>
> 从另一方面来说，用户不需要来验证哈希值是否正确，因为每个节点都已验证过。
>
> 一般来说，每12到15秒就会有一个矿工挖出一个新区块。如果矿工解谜的时间开始出现更快或更慢的倾向，算法会自动调整问题的难度，以使矿工解谜的时间稳定在14秒左右。
>
> 矿工有一定几率能挖到新区块赚取以太币奖励，他们的赚钱能力取决于运气和他们投入的计算能力。
>
> 以太坊使用的工作量证明算法被称为“ethash”，它被设计的需要更多内存，从而增大了使用昂贵的ASIC矿机挖矿的难度，因为ASIC矿机的出现严重压榨了使用其他设备矿工的收益，以至于在比特币中唯一能盈利的挖矿形式就是使用这种定制化的芯片。
>
> 从某种意义上来说，ethash可能已经成功实现了这一目标，因为专用的ASIC矿机不能用于挖掘以太坊（至少目前还没有）。
>
> 此外，由于以太坊将要从工作量证明挖矿逐步过渡到权益证明挖矿，因而购买ASIC矿机可能不是一个明智的选择，因为一旦以太坊转向权益证明它必将被淘汰。

15. 常用的共识协议：工作量证明Pow和权益证明Pos，其他Poa（活动证明）
16. 简述权益证明的工作原理：权益证明是根据持有货币的数量和时间随即选择区块的创建者，不是计算密集型的挖矿形式。
17. 以太坊的共识机制：

> 截至2018年初，以太坊使用工作量证明建立共识，但在未来它将转向权益证明。
>
> 活动证明在比特币的工作量证明中引入了一种新形式的激励结构，这种混合结构结合了工作量证明和权益证明。为避免系统出现恶性通货膨胀，应该停发新的加密货币，也就是说矿工的挖矿行为不再能拿到挖矿奖励。
>
> 这样系统中的加密货币数量就恒定了。在活动证明中，矿工使用工作量证明产生区块，加密货币的持有者通过权益证明签署区块，交易费将按比例分给矿工和签署该块的验证人。

18. 签署交易需要的工具：用户私钥。
19. 私钥丢失，用户如何恢复以太坊账户：12字助记词

------

### 智能合约

1. ABI是什么：

> 简单来说，“ABI”就是低级别的“API”。
>
> ABI（Application Binary Interface）应用程序二进制接口，从本质上讲就是你调用智能合约中的函数并获取它返回值的方式。
>
> ABI中定义了如何调用智能合约中的函数以及应该选用哪种二进制格式将信息从一个程序组件传递到下一个程序组件的详细信息。
>
> 以太坊智能合约以字节码的形式部署在以太坊区块链上，一个智能合约中可能会有多个函数。所以说，有了ABI你才可以指定调用智能合约中的哪个函数，才能保证函数的返回值是你期望的格式。
>
> 这是一个来自以太坊ABI规范的例子：
>
> ```solidity
> contract Foo {function bar(real[2] xy) {}function baz(uint32 x, bool y) returns (bool r) { r = x > 32 || y; }function sam(bytes name, bool z, uint[] data) {}}
> ```
>
> 如果我们想使用参数“69”和“真”调用函数baz（），我们总共会传递68字节的数据，整个过程可以分解为：
>
> 0xcdcd77c0：baz（）函数的ID。这是函数baz（uint32，bool）以ASCII形式编码的Keccak-256哈希值的前4个字节。
>
> *0x0000000000000000000000000000000000000000000000000000000000000045* ：
>
> 传入函数baz（）的第一个参数，32位无符号整数69被填充为32个字节（10进制中的69换算成16进制为45）。
>
> *0x00000000000000000000000000000000000000000000000000000000000000000001* ：
>
> 传入函数baz（）的第二个参数，布尔值真，也就是1，被填充为32个字节。
>
> 这68个字节会存放在交易的数据字段（data），需要注意的是，一定要仔细检查交易数据字段中添加的内容，因为在将其传递给智能合约时可能会产生意外的，甚至可能是恶意的副作用。）
>
> 为了避免出现生成函数ID时的常见错误，在此过程中必须使用规范的数据类型，就比如说使用标准的256位无符号整型（uint256）而不是无符号整型（uint）。
>
> 在Solidity中计算上述sam（）函数ID的的代码如下：
>
> ```solidity
> bytes4(sha3("sam(bytes,bool,uint256[])")
> ```
>
> 在这里可以使用诸如web3.js等高级程序库来抽象大部分的细节，不过提供给web3.js的JSON格式ABI是必不可少的。
>
> ***注意：******ABI是一个抽象，它并不是以太坊核心协议的一部分* **。任何人都可以为自己的智能合约定义专属的ABI，这些智能合约的任何调用者都必须遵守该ABI的规定才能得到有意义的调用结果。但是，对于所有开发人员来说，使用Solidity，Serpent和web3.js更为简单，这些也都符合ABI的规定。

2. 智能合约是什么：智能合约就是用多种语言编写的计算机代码，智能合约存在于区块链上，按照自身嵌入的规则执行相关操作，可以看做是参与者之间的契约。
3. 智能合约使用场景： 举一个简单的商品买卖场景，买方在以太坊中部署一个智能合约并向其中存入资金，卖方看到存入的资金后发送商品，买方收到商品后通过智能合约支付货款。这里的智能合约可以看作是一个保障淘宝交易的去中心化的支付宝。
4. 什么是Metamask：一款插件类型以太坊钱包。使用infura.io节点。不支持挖矿和部署智能合约。
5. 智能合约的执行是免费的吗：不是，只能通过执行交易调用智能合约，交易需要燃料费用。
6. 查看智能合约是免费的：是，查询不需要执行交易。
7. 谁来执行智能合约：矿工
8. 为什么调用智能合约的函数需要花钱：

> 除了一些不会改变智能合约状态，除了返回值之外没有其他逻辑的函数之外，调用智能合约中的函数都是需要花钱的。
>
> 这笔花费中，除了向智能合约中转入以太币执行调用之外，调用改变智能合约状态的函数需要花费燃料来执行。

9. 为什么以太坊要引入燃料费用：

> 因为矿工使用自己的计算机（矿机）执行智能合约代码，矿工如果能收回购买机器的成本并获得盈利才能保证整个系统生态的安全性，所以以太坊设计使得矿工可以通过执行调用者请求的代码来赚取燃料费用，从而维持一个健康的生态。

10. 燃料价格是否能决定交易被处理的时间：是的，也不全是。一般来说，你支付的燃料价格越高，交易越有可能被加入区块链。尽管如此，燃料价格并不能保证交易更快地被处理。
11. 交易的燃料使用量取决于什么：燃料使用量取决于存储的用量，指令（操作码）的类型和数量。每一条以太坊虚拟机的操作码都明确规定了所需燃料的数量。
12. 交易费如何计算： 交易费 = 使用的燃料数量* 燃料价格（交易者指定）
13. 如果执行智能合约花费少于交易者支付的燃料费用，师傅会获得退款：是。
14. 如果执行花费超过了交易者支付的燃料费用：不会获得退款，且燃料好近执行就会停止，合约状态不会改变。
15. 谁来支付合约费用：调用者。
16. 节点在哪里运行代码：以太坊虚拟机EVM，EVM规范是以太坊协议的一部分，以太坊虚拟机是节点运行的一个进程。
17. 以太坊虚拟机需要什么工具来运行合约：智能合约的字节码，由高级别语言 solidity编译生成。
18. 以太坊虚拟机包含哪些部分：内存区域，堆栈，执行引擎。
19. remix是什么：用于开发测试部署智能合约的在线工具。
20. remix可以连接到那些节点：使用metamask钱包连接到公共节点，geth钱包俩捏到本地节点，使用js虚拟机连接到内存中的模拟节点。
21. Dapp是什么：

> 应用程序通常包含一个与某些中心化资源（由组织拥有）交互的客户端，通常有一个与中心化数据层相连的中间层。如果中心化数据层中的数据丢失，则无法（轻松）恢复。
>
> DApp表示去中心化的应用程序。DApp通过智能合约与区块链网络交互，它们使用的数据驻留在智能合约的实例中，与中心化的数据相比，去中心化的数据安全性更高。

22. solidity是静态语言吗：是的，类型在编译阶段是已知的。

23. solidity中什么结构与java中的class相对应：Contract

24. 智能合约的实例是什么：在区块链上部署的一个智能合约。

25. java和solidity差异：solidity支持多继承，不支持重载。

26. solidity需要指定的第一个参数是：solidty版本。

27. 智能合约包含什么：存储变量，函数和事件

28. 智能合约有哪些类型的函数：constructor， fallback function，constant function和修改智能合约状态的函数

29. 单个文件包含多个智能合约定义：可以

30. 两个智能合约可以通过哪些方式进行交互：调用，创建和继承另一个智能合约。

31. 尝试部署具有多个智能合约的文件时：只能部署最后一个合约，其他的被忽略。`todo`

32. 大型项目，是否需要所有合约保存在一个文件里：可以通过 import引入

33. 是否可以导入远程文件：可以  import “http://github.com/<**owner**>/<**repo**>/<**path** to the file>”

34. 以太坊虚拟机内存有哪些部分：存储 storage 内存 memory calldata

    >存储：可以把存储想象成一个数据库。每个智能合约都管理自己的存储变量，从而得到一个键值对数据库（256位的键和值）。存储与普通数据库的唯一区别就是，由于存在燃料费用的问题它读取和写入操作的成本更高。
    >
    >内存： 内存是一个临时性的存储。当函数调用执行完毕后，内存中的数据将会被释放。你可以在内存中分配各种复杂的数据类型，如数组和结构体。
    >
    >calldata：Calldata可以理解为一个函数调用堆栈（Callstack）。它是临时的，不可修改的，它存储着以太坊虚拟机的执行数据。

35. 存储区和内存区分别存储哪些变量：状态变量和局部变量（对状态变量的引用）位于存储区，函数参数位于内存区。

36. ``` contract MyContract {// part 1(存储区) uint count;uint[] totalPoints;function localVars(){// part 2 （存储）    uint[] localArr;// part 3  （内存区）  uint[] memory memoryArr;// part 4 （对存储的引用）    uint[] pointer = totalPoints;  }} ```

37. EVM调用和非EVM调用的区别：

> EVM调用是智能合约中的函数调用，触发函数执行并需要燃料
>
> 非EVM调用读取公开可见的数据，不需要燃料

38. 设定智能化的以太币余额限制：

``` Contract MyCon{uint public balanceLimit = 999; function A() payable{``` 

 ```this.balance+msg.value>balanceLimit){throw;//超额后回滚}}} ```

39. 需要设么工具与Dapp的智能合约进行交互：ABI和字节码
40. ABI的作用是：智能合约的公共接口的描述 Dapp用ABI来调用智能合约
41. 为什么要使用大数运算程序库（bigNumber library）：js无法处理大数字。
42. 检查Dapp代码开头是否设置了web3提供程序：metamask会用自己的web3提供程序覆盖它。
43. .call和.send区别：.send”发起交易并且产生费用，而“.call”仅查询智能合约的状态不产生费用。
44. 以太坊的可扩展性问题有什么解决方案：解决可拓展性问题的思路是使用链下交易机制。具体的解决方案有状态通道（state channels）和plasma。



